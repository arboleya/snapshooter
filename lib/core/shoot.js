// Generated by CoffeeScript 1.6.2
(function() {
  var Crawler, Shoot, connect, exec, fs, fsu, path;

  fs = require('fs');

  exec = (require('child_process')).exec;

  path = require('path');

  fsu = require('fs-util');

  connect = require('connect');

  Crawler = require('./crawler');

  /*
    Instantiate a crawler for the first url,
    Crawler returns a source and "<a href=''>" links url
  
    The links url are filtered ( i.e. external links are not crawled ),
    and then written to disk
  */


  module.exports = Shoot = (function() {
    Shoot.prototype.crawled = {};

    Shoot.prototype.skipped_urls = {};

    Shoot.prototype.domain = null;

    Shoot.prototype.root_folder = null;

    Shoot.prototype.pending_urls = null;

    Shoot.prototype.connections = 0;

    Shoot.prototype.max_connections = 10;

    Shoot.prototype.start_time = null;

    Shoot.prototype.ignore = null;

    Shoot.prototype.crawled_files_num = 0;

    Shoot.prototype.failed_files_num = 0;

    Shoot.prototype.skipped_files_num = 0;

    function Shoot(the, cli) {
      var all, code, first_url, flags, msg, reg, _ref;

      this.the = the;
      this.cli = cli;
      if (!this.has_phantom()) {
        msg = "" + 'Error'.bold.red + " Install " + 'phantomjs'.yellow + " before indexing pages!\n  • http://phantomjs.org";
        console.log(msg);
        process.exit(code = process.ENOENT);
      }
      this.pending_urls = [];
      if (this.cli.argv.ignore != null) {
        _ref = /(?:\/)(.+)(?:\/)([mgi]+)$/.exec(this.cli.argv.ignore), all = _ref[0], reg = _ref[1], flags = _ref[2];
        reg = reg.replace(/([\/\?])/g, '\\/$1');
        this.ignore = new RegExp(reg, flags);
      }
      if (this.cli.argv.address) {
        if (!~this.cli.argv.address.indexOf('http')) {
          first_url = this.cli.argv.address = 'http://' + this.cli.argv.address;
          this.domain = (first_url.match(/https?:\/\/[^\/]+/))[0];
          this.root_folder = first_url;
        }
      } else {
        first_url = this.cli.argv.file;
        this.domain = (this.cli.argv.match.match(/(.+)\/[\w-_\.]+\.html/))[0];
        reg = /https?:\/\/[^\/]+\/(.+)\/[\w-_\.]+\.html/;
        this.root_folder = (first_url.match(reg))[0];
      }
      this.start_time = (new Date).getTime();
      this.crawl(first_url);
    }

    Shoot.prototype.crawl = function(url) {
      var _this = this;

      if (this.crawled[url] !== void 0) {
        return;
      }
      this.crawled[url] = false;
      if (!this.cli.argv.stdout) {
        console.log('>'.bold.yellow, url.grey);
      }
      this.connections++;
      return new Crawler(this.cli, url, function(source) {
        if (!_this.cli.argv.stdout) {
          console.log('< '.bold.cyan, url.grey);
        }
        _this.connections--;
        _this.crawled[url] = true;
        if (source != null) {
          _this.crawled_files_num++;
        } else {
          _this.failed_files_num++;
        }
        if (_this.cli.argv.stdout) {
          console.log(source);
        } else {
          _this.save_page(url, source);
        }
        if (_this.cli.argv.once) {
          return _this.finish();
        } else {
          return _this.after_crawl(source);
        }
      });
    };

    Shoot.prototype.after_crawl = function(source) {
      var absolute, links, match, passed, reg, relative, skipped;

      reg = /<a\s+href\s*=\s*["']+(?!http)([^"']+)/g;
      links = [];
      if (source != null) {
        while ((match = reg.exec(source)) != null) {
          relative = match[1];
          absolute = this.domain + relative;
          passed = this.url_is_passing(relative, absolute);
          if (passed) {
            this.pending_urls.push(absolute);
          } else {
            skipped = passed !== -1;
            skipped && (skipped = this.skipped_urls[absolute] === void 0);
            if (skipped) {
              this.skipped_urls[absolute] = true;
              this.skipped_files_num++;
            }
            if (skipped && this.cli.argv.verbose) {
              console.log('• INFO '.bold.cyan + ("skipping " + absolute.yellow).cyan);
            }
          }
        }
      }
      while (this.connections < this.max_connections && this.pending_urls.length) {
        this.crawl(this.pending_urls.shift());
      }
      if (this.connections === 0) {
        return this.finish();
      }
    };

    Shoot.prototype.save_page = function(url, source) {
      var output_file, output_folder, relative_url;

      relative_url = (url.replace(this.domain, '')) || '/';
      output_folder = path.join(this.cli.argv.output, relative_url);
      output_file = path.join(output_folder, 'index.html');
      if (!fs.existsSync(output_folder)) {
        fsu.mkdir_p(output_folder);
      }
      fs.writeFileSync(output_file, source);
      return console.log('✓ '.green, relative_url);
    };

    Shoot.prototype.finish = function() {
      var address, ms, root;

      if (!this.cli.argv.stdout) {
        ms = ((new Date).getTime() - this.start_time) + ' ms';
        console.log(("\n★  Application crawled successfully in " + ms.magenta).green);
        console.log('\t Indexed: ' + this.crawled_files_num);
        console.log('\t Skipped: ' + this.skipped_files_num);
        console.log('\t Failed: ' + this.failed_files_num);
      }
      if (!this.cli.argv.server) {
        return;
      }
      this.conn = connect().use(connect["static"](this.cli.argv.output)).listen(this.cli.argv.port);
      address = 'http://localhost:' + this.cli.argv.port;
      root = this.cli.argv.output;
      return console.log(("\nPreview server started for " + root + " at: \n\t").grey, address);
    };

    Shoot.prototype.has_phantom = function() {
      var _this = this;

      return exec("phantomjs -v", function(error, stdout, stderr) {
        return /phantomjs: command not found/.test(stderr);
      });
    };

    Shoot.prototype.url_is_passing = function(relative, absolute) {
      var flag, flags, not_anchor, not_backwards, not_crawled, not_ignore, not_image, not_pdf, not_slash, not_zip, passed, _i, _len;

      not_slash = absolute !== '/';
      not_crawled = this.crawled[absolute] === void 0;
      not_anchor = relative !== '#';
      not_image = !(/\.(jpg|jpeg|gif|png)$/m.test(absolute));
      not_zip = !(/\.(zip|tar(\.gz)?)$/m.test(absolute));
      not_pdf = !(/\.(pdf)$/m.test(absolute));
      if (this.cli.argv.forward) {
        not_backwards = (absolute.indexOf(this.root_folder)) === 0;
      } else {
        not_backwards = true;
      }
      if (this.ignore != null) {
        not_ignore = !(this.ignore.test(absolute));
      } else {
        not_ignore = true;
      }
      flags = [not_slash, not_crawled, not_anchor, not_image, not_zip, not_pdf, not_ignore, not_backwards];
      passed = true;
      for (_i = 0, _len = flags.length; _i < _len; _i++) {
        flag = flags[_i];
        passed && (passed = flag);
      }
      if (passed) {
        return true;
      } else {
        if (not_crawled === false) {
          return -1;
        } else {
          return false;
        }
      }
    };

    return Shoot;

  })();

}).call(this);

/*
//@ sourceMappingURL=shoot.map
*/
